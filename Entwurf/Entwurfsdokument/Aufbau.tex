\chapter{Aufbau}

\newcommand{\class}[1]{\textcolor{BlueViolet}{\sloppy{#1}}}
\newcommand{\interface}[1]{\textcolor{OliveGreen}{\mbox{\sloppy{#1}}}}
\newcommand{\xna}[1]{\textcolor{Gray}{\sloppy{#1}}}



\section{Architektur}

Die grundlegende Architektur des Spiels basiert auf der Spielkomponenten-Infrastruktur des XNA-Framework, die mit Spielzuständen kombiniert wird. Die abstrakten Klassen \class{GameStateComponent} und \class{DrawableGameStateComponent} erben von den von XNA bereitgestellten Klassen \xna{GameComponent} und \xna{DrawableGameComponent} implementieren zusätzlich die Schnittstelle \interface{IGameStateComponent}. Sie unterscheiden sich von den XNA-Basisklassen dadurch, dass sie immer eine Referenz auf einen bestimmten Spielzustand halten und nur in Kombination mit diesem zu verwenden sind.
\\\\
Die Spielzustände erben von der abstrakten Basisklasse \class{GameScreen} und halten eine Liste von \interface{IGameStateComponent}-Objekten. Wird ein Spielzustand aktiviert, indem von einem anderen Spielzustand aus zu ihm gewechselt wird oder indem er der Startzustand ist, dann weist er seine Liste von \interface{IGameStateComponent}-Objekten dem \xna{Components}-Attribut der \class{Game}-Klasse zu, die von der vom XNA-Framework bereitgestellten abstrakten Klasse \xna{Game} erbt. So ist zu jedem Zeitpunkt während der Laufzeit des Spiels ein Spielzustand aktiv, der die aktuelle Liste von Spielkomponenten verwaltet.
\\\\
Die Spielkomponenten, die nicht gezeichnet werden und nur auf Eingaben reagieren, haben nur eine Update()-Methode und erben von \class{GameStateComponent}. Dies sind vor allem verschiedene Input-Handler, welche Tastatur- und Mauseingaben verarbeiten und beispielsweise die Kameraposition und das Kameratarget ändern oder Spielobjekte bewegen.
\\\\
Spielkomponenten, die neben der Update()-Methode auch eine Draw()-Methode besitzen, erben von \class{DrawableGameStateComponent}. Dies sind vor allem die Elemente, aus denen die grafische Benutzeroberfläche zusammengesetzt ist, deren abstrakte Basisklasse \class{Widget} darstellt. [weitere Erklärungen zu Widgets...]
\\\\
Alle Spielobjekte implementieren die Schnittstelle \interface{IGameObject}. Die abstrakte Klasse \class{GameModel} repräsentiert dabei ein Spielobjekt, das aus einem 3D-Modell besteht, und hält zu diesem Zweck eine Referenz auf ein Objekt der Klasse \xna{Model} aus dem XNA-Framework sowie weitere Eigenschaften wie Position, Drehung und Skalierung.

Spielobjekte sind keine Komponenten, sondern werden in einer Spielwelt zusammenfasst, die durch die Klasse \class{World} repräsentiert wird. Die Spielwelt ist ein \class{DrawableGameStateComponent} und ruft in ihrer Update()- und Draw()-Methoden jeweils die dazugehörigen Methoden aller in ihr enthaltenen Spielobjekte auf.
\\\\
Shadereffekte werden durch die abstrakte Klasse \class{RenderEffect} und die von ihr abgeleiteten Klassen gekapselt. Ein \class{RenderEffect} enthält ein Rendertarget vom Typ \xna{RenderTarget2D} als Attribut und implementiert jeweils eine Begin()- und eine End-Methode. In der Methode Begin() wird das aktuell von XNA genutzte Rendertarget auf einem Stack gesichert und das Rendertarget des Effekts wird als aktuelles Rendertarget gesetzt.

Nach dem Aufruf von Begin() werden alle Draw()-Calls von XNA auf dem gesetzten Rendertarget ausgeführt. Es wird also in eine im \xna{RenderTarget2D}-Objekt enthaltene Bitmap gezeichnet. Dabei wird von den Draw()-Methoden der \class{GameModel}s die DrawModel(GameModel)-Methode des \class{RenderEffect}s aufgerufen, der die Modelle mit bestimmten Shadereffekten in die Bitmap zeichnet.

In der End()-Methode wird schließlich das auf dem Stack gesicherte vorher genutzte Rendertarget wiederhergestellt und das Rendertarget des \class{RenderEffect}s wird, unter Umständen verändert durch Post-Processing-Effekte, auf dieses übergeordnete Rendertarget gezeichnet.



\section{Klassendiagramm}

\section{Verwendete Entwurfsmuster}

